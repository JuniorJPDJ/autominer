#!/usr/bin/env perl

# Copyright (c) 2017 Todd Freed <todd.freed@gmail.com>
# 
# This file is part of autominer.
# 
# autominer is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# autominer is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License

use strict;
use warnings;

use File::Basename;
use Cwd;
our $repodir;
BEGIN { $repodir = dirname(Cwd::realpath("$0/..")) }
use lib "$repodir/lib";
use util;
use release;
override_warn_and_die();

use Errno;
use Time::Piece;
use Data::Dumper;
use JSON::XS;
use POSIX ':sys_wait_h';
use config;
use miner;
use perf;
use xlinux;
use ring;
use history;

our $verbose = 0;
our %opts = (
    'profile'         => 'default'

  , 'price-method'    => 'opportunity'  # trailing | opportunity
  , 'trailing-window' => 'm5'           # trailing 5 minute average

  , 'historical-samples' => 60 * 10     # ten minutes

  , 'opportunity-threshold' => 0
  , 'intensity-scaling' => 1
  , 'speed-scaling' => 1
  , 'price-scaling' => 1

, 'actual-speed-samples' => 1

  # miner executables expected to be in $PATH by default
  , 'ccminer_path'              => 'ccminer'
  , 'ccminer_cryptonight_path'  => 'ccminer-cryptonight'
  , 'ethminer_path'             => 'ethminer'
  , 'nheqminer_cuda_path'       => 'nheqminer_cuda'
  , 'sgminer_path'              => 'sgminer'
  , 'eqm_path'                  => 'eqm'
);
my %optargs = (
    'help|h'            => \$opts{help}
  , 'version|V'         => \$opts{version}
  , 'verbose|v'         => \$opts{verbose}

, 'price-method=s'      => \$opts{"price-method"}
  , 'trailing-window=s' => \$opts{"trailing-window"}

, 'use-actual-price=i'    => \$opts{"use-actual-price"}
, 'use-actual-speed=i'    => \$opts{"use-actual-speed"}
  , 'historical-samples=i'  => \$opts{"historical-samples"}      # samples to use in historical speed calculation

, 'switching-threshold=i' => \$opts{"switching-threshold"}
, 'opportunity-threshold=i' => \$opts{"opportunity-threshold"}

  , 'data-dir=s'        => \$opts{datadir}
  , 'profile=s'         => \$opts{profile}
  , 'payout-address=s'  => \$opts{"payout-address"}
  , 'worker=s'          => \$opts{worker}
  , 'switching-period=i'=> \$opts{"switching-period"}
  , 'cards=s'           => \$opts{cards}
  , 'history-retention=i'       => \$opts{"history-retention"}

  , 'nicehash-usa!'    => \$opts{"nicehash-usa"}
  , 'nicehash-eu!'     => \$opts{"nicehash-eu"}

  , 'ccminer-path=s'              => \$opts{ccminer_path}
  , 'ccminer-cryptonight-path=s'  => \$opts{ccminer_cryptonight_path}
  , 'ethminer-path=s'             => \$opts{ethminer_path}
  , 'nheqminer-cuda-path=s'       => \$opts{nheqminer_cuda_path}
  , 'sgminer-path=s'              => \$opts{sgminer_path}
  , 'eqm-path=s'                  => \$opts{eqm_path}

  , 'intensity-scaling=f' => \$opts{"intensity-scaling"}
  , 'speed-scaling=f' => \$opts{"speed-scaling"}
  , 'actual-speed-samples=i' => \$opts{"actual-speed-samples"}
  , 'price-scaling=f' => \$opts{"price-scaling"}
);
configure(\%optargs, \%opts);

if($opts{help})
{
  print <<HELP;
autominer - an autoswitching miner for linux, version $release::number

 >> BTC donations : 184AtMD3AihYke2bKQD9AXh4Dgzvtr7jhA (hossbeast)

usage: autominer mine [options]

 --help                     print this help text
 --version                  print the version number, exit
 --verbose                  print commands as they are run
 --quiet                    dont echo output from the miner to stdout

required
 --payout-address <addr>    where to send mining rewards - part of the username mining parameter
 --cards <device-ids>       comma-separated list of devices ids to mine with
 --data-dir <path>          base location for perf, history and market data

required - one or more
 --nicehash-usa             consider mining on algos in nicehash.usa
 --nicehash-eu              consider mining on algos in nicehash.eu

optional
 --profile <name>           separate config file, perf and history data
 --worker <name>            name of this mining rig / worker - part of the username mining parameter
 --switching-period <seconds>         how frequently to re-evaluate what to mine
 --history-retention <number>       number of per-switching-period history files to retain

 --price-method opportunity  use opportunity price
 --price-method trailing     use trailing average price paid to all sellers
 --trailing-window <seconds> for price-method=trailing, which window to use

 --historical-samples <seconds> for speed-method historical, number of trailing perf samples to estimate future performance from

 --switching-threshold <pct> only switch if the predicted profit difference meets or exceeds the threshold

optional - miner executables
 --ccminer-path <path>              path to the ccminer executable
 --ccminer-cryptonight-path <path>  path to the ccminer-cryptonight executable
 --ethminer-path <path>             path to the ethminer executable
 --nheqminer-cuda-path <path>       path to the nheqminer_cuda executable
 --sgminer-path <path>              path to the sgminer executable
 --eqm-path <path>                  path to the eqm executable

For more information visit https://github.com/hossbeast/autominer
HELP
  exit 0
}
if($opts{version})
{
  print "autominer-$release::number\n";
  exit 0;
}

die "missing required config --payout-address" unless $opts{"payout-address"};
die "missing required config --data-dir" unless $opts{datadir};
die "missing required config --cards" unless defined $opts{"comma-cards"};
die "missing required config --nicehash-usa or --nicehash-eu" unless $opts{"nicehash-usa"} or $opts{"nicehash-eu"};

$SIG{CHLD} = 'IGNORE';

# ensure directories exist
mkdirp("$opts{datadir}/bench/$opts{profile}");
mkdirp("$opts{datadir}/history/profile/$opts{profile}");
mkdirp("$opts{datadir}/history/payout-address/" . $opts{"payout-address"} . "/profile/$opts{profile}");
if($opts{worker})
{
  mkdirp("$opts{datadir}/history/worker/$opts{worker}/profile/$opts{profile}");
}
mkdirp("/tmp/run/autominer/aggregator");

# load miners
my $benchdir = "$opts{datadir}/bench/$opts{profile}";
my %miners = enumerate_miners("$repodir/miners");
die "no miners" unless %miners;

for my $miner (values %miners)
{
  # load supported algorithms
  enumerate_algos($miner);

  mkdirp("$opts{datadir}/bench/$opts{profile}/$$miner{name}");

  # load perf data per algo
  for my $algo (values %{$$miner{algos}})
  {
    perf_initialize($miner, $algo, $benchdir);
  }
}

my %histories;
$histories{profile} = history_init("profile", $opts{profile});
$histories{"payout-address"} = history_init("payout-address", $opts{"payout-address"}, $opts{profile});
if($opts{worker})
{
  $histories{worker} = history_init("worker", $opts{worker}, $opts{profile});
}

my $quit = 0;
my $mining = { algo => '', market => '', miner => '', started => 0, speeds => [] };
my %rates;
my %opportunities;
my $present = undef;
my $miner_pid = 0;
my $perf_pid = 0;
my $nicehash_aggregator_eu_pid = 0;
my $nicehash_aggregator_usa_pid = 0;

$SIG{CHLD} = sub {
  local ($!, $?);
  while((my $pid = waitpid(-1, WNOHANG)) > 0) {
    my $exit = $? >> 8;
    my $sig = $? & 127;

    if($pid == $miner_pid)
    {
      printf("CHLD miner-pid=$pid, status=$?, exit=$exit, signal=$sig\n");
      $miner_pid = 0;
    }
    elsif($pid == $perf_pid)
    {
      printf("CHLD perf-pid=$pid, status=$?, exit=$exit, signal=$sig\n");
      $perf_pid = 0;
    }
    elsif($pid == $nicehash_aggregator_eu_pid)
    {
      printf("CHLD nicehash-aggregator-eu-pid=$pid, status=$?, exit=$exit, signal=$sig\n");
      $nicehash_aggregator_eu_pid = 0;
    }
    elsif($pid == $nicehash_aggregator_usa_pid)
    {
      printf("CHLD nicehash-aggregator-usa-pid=$pid, status=$?, exit=$exit, signal=$sig\n");
      $nicehash_aggregator_usa_pid = 0;
    }

    # affirmative murder
    kill 9, $pid;
  }
};

$SIG{TERM} = $SIG{QUIT} = sub {
  $quit = 1;
};

# spawn market aggregators if they are not already running
for my $market ("usa", "eu")
{
  next unless $opts{"nicehash-$market"};

  my $pid;
  if(($pid = fork()) == 0)
  {
    my $holder = lock_obtain("/tmp/run/autominer/aggregator/nicehash-$market");
    if($holder)
    {
      print("nicehash-aggregator --region $market already running : $holder\n") if $verbose;
      exit;
    }

    chdir("/");
    POSIX::close(0);
    pr_set_pdeathsig(9);

    my @cmd = ("$repodir/bin/nicehash-aggregator", "--region", "$market");
    exec { $cmd[0] } @cmd;
  }

  $nicehash_aggregator_eu_pid = $pid if $market eq "eu";
  $nicehash_aggregator_usa_pid = $pid if $market eq "usa";
}

# pipes are named according to which process writes to it
my ($miner_reader_fd, $miner_writer_fd) = POSIX::pipe();
my ($perf_reader_fd, $perf_writer_fd) = POSIX::pipe();
my ($autominer_reader_fd, $autominer_writer_fd) = POSIX::pipe();

if($verbose)
{
  print("miner-reader $miner_reader_fd miner-writer $miner_writer_fd\n");
  print("perf-reader $perf_reader_fd perf-writer $perf_writer_fd\n");
  print("autominer-reader $autominer_reader_fd autominer-writer $autominer_writer_fd\n");
}

sub getrates
{
  my ($market, $window) = @_;

  my $path = "$opts{datadir}/rates/$market/$window";
  open(my $fh, "<$path") or die "open($path) : $!";
  my $text = do { local $/ = undef ; <$fh> };
  close $fh;

  decode_json($text);
}

sub getopportunities
{
  my ($market) = @_;

  my $path = "$opts{datadir}/opportunities/$market/present";
  open(my $fh, "<$path") or die "open($path) : $!";
  my $text = do { local $/ = undef ; <$fh> };
  close $fh;

  decode_json($text);
}

# load market stats
$rates{"nicehash-usa"} = getrates("nicehash-usa", $opts{"trailing-window"}) if $opts{"nicehash-usa"};
$opportunities{"nicehash-usa"} = getopportunities("nicehash-usa") if $opts{"nicehash-usa"};

$rates{"nicehash-eu"} = getrates("nicehash-eu", $opts{"trailing-window"}) if $opts{"nicehash-eu"};
$opportunities{"nicehash-eu"} = getopportunities("nicehash-eu") if $opts{"nicehash-eu"};

while(!$quit)
{
  # assemble mining options
  my $current_option;
  my @options;
  for my $market ("nicehash-usa", "nicehash-eu")
  {
    next unless $opts{$market};

    while(my($minername, $miner) = each %miners)
    {
      while(my($algoname, $algo) = each %{$$miner{algos}})
      {
        next unless $rates{$market}{$algoname};

        my $option = {
            miner => $miner
          , algo => $algo
          , market => $market
        };

        $$option{average_rate} = average_rate($mining, $option, \%rates, \%opportunities, $present);
        $$option{opportunity_rate} = opportunity_rate($mining, $option, \%rates, \%opportunities, $present);
        $$option{actual_rate} = actual_rate($mining, $option, \%rates, \%opportunities, $present);
        $$option{predicted_rate} = predicted_rate($mining, $option, \%rates, \%opportunities, $present);
        $$option{predicted_profit} = predicted_profit($mining, $option, \%rates, \%opportunities, $present);
        $$option{average_speed} = average_speed($mining, $option, \%rates, \%opportunities, $present);
        $$option{actual_speed} = actual_speed($mining, $option, \%rates, \%opportunities, $present);

        push @options, $option;

        if($$mining{market} eq $$option{market} && $$mining{miner} eq $$option{miner}{name} && $$mining{algo} eq $$option{algo}{name})
        {
          $current_option = $option;
        }
      }
    }
  }

  # select the best option, order of descending profit
  @options = sort { $$b{predicted_profit} <=> $$a{predicted_profit} } @options;
  my $option = undef;
  for my $o (@options)
  {
    if($option) { }
    elsif(!$present)
    {
      $option = $o;
    }
    elsif($o == $current_option)
    {
      $option = $o;
    }
    elsif($$current_option{predicted_profit} == 0)
    {
      $option = $o;
    }
    else
    {
      my $delta = $$o{predicted_profit} - $$current_option{predicted_profit};
      my $variance = ($delta / $$current_option{predicted_profit}) * 100;

      if($variance >= $opts{"switching-threshold"})
      {
        $option = $o;
      }
    }
  }

  # print details about the selection
  for my $o (@options)
  {
    my $profit = "(no data)";
    if($$o{algo}{speed} != 0xFFFFFFFF) {
      $profit = sprintf("%14.8f", $$o{predicted_profit});
    }

    # skip everything below the profit threshold
    last if $$o{predicted_profit} == 0;

    printf "%-15s %-20s %-20s"
      , $$o{market}
      , $$o{miner}{name}
      , $$o{algo}{name}
    ;
    if($opts{"use-actual-price"} && $$mining{miner} eq $$o{miner}{name} && $$mining{algo} eq $$o{algo}{name} && $$mining{market} eq $$o{market})
    {
      printf(" rate [ %14.8f   %14.8f  (%14.8f)]", $$o{opportunity_rate}, $$o{average_rate}, $$o{actual_rate})
    }
    elsif($opts{"price-method"} eq "trailing")
    {
      printf(" rate [ %14.8f  (%14.8f)  %14s ]", $$o{opportunity_rate}, $$o{average_rate}, $$o{actual_rate})
    }
    else
    {
      printf(" rate [(%14.8f)  %14.8f   %14s ]", $$o{opportunity_rate}, $$o{average_rate}, $$o{actual_rate})
    }

    print(" * speed");
    if($opts{"use-actual-speed"} && $$mining{miner} eq $$o{miner}{name} && $$mining{algo} eq $$o{algo}{name} && $$mining{market} eq $$o{market})
    {
      printf(" [ %14.8f  (%14.8f)]", $$o{average_speed}, $$o{actual_speed});
    }
    else
    {
      printf(" [(%14.8f)  %14.8f ]", $$o{average_speed}, $$o{actual_speed});
    }

    printf(" = profit %-10s", $profit);

    if($$mining{miner} eq $$o{miner}{name} && $$mining{algo} eq $$o{algo}{name} && $$mining{market} eq $$o{market})
    {
      print(" <<<");  # current option
    }
    else
    {
      print("   ");
    }

    # newly selected
    if($option and $option == $o)
    {
      print(" <<=")
    }

    print("\n");
  }

  my $market = $$option{market};
  my $miner = $$option{miner};
  my $algo = $$option{algo};

  # open a new bench file to store the results of this run
  my $miner_bench_dir = "$opts{datadir}/bench/$opts{profile}/$$miner{name}";
  my $algo_bench_dir = "$miner_bench_dir/$$algo{name}";
  my $bench_file_num = ($$algo{head} || 0) + 1;
  my $bench_path = sprintf("%s/%05u", $algo_bench_dir, $bench_file_num);
  open(my $bench_fh, ">$bench_path") or die "open($bench_path) : $!";

  # the header lines contains details about the selected option
  my $perf_summary = perf_summary($mining, $option, \%rates, \%opportunities, $present);
  syswrite($bench_fh, $perf_summary, length($perf_summary));

  # advance the history files
  for my $history (values %histories)
  {
    history_advance($history, $bench_path)
  }

  if($market ne $$mining{market} || $$miner{name} ne $$mining{miner} || $$algo{name} ne $$mining{algo} || !$miner_pid || !$perf_pid)
  {
    miner_env_setup(market => $market, miner => $$miner{name}, algo => $$algo{name});

    # miner writes to autominer
    killfast([ \$miner_pid, \$perf_pid ]);
    $miner_pid = fork;
    if($miner_pid == 0)
    {
      POSIX::dup2($miner_writer_fd, 1);

      pr_set_pdeathsig(9);

      my @cmd = ($$miner{path}, "mine");
      exec { $cmd[0] } @cmd;
    }

    # perf reads from autominer via one pipe, and writes to autominer via a separate pipe
    $perf_pid = fork;
    if($perf_pid == 0)
    {
      POSIX::dup2($autominer_reader_fd, 0);
      POSIX::dup2($perf_writer_fd, 1);

      pr_set_pdeathsig(9);

      my @cmd = ($$miner{path}, "perf");
      exec { $cmd[0] } @cmd;
    }

    $$mining{market} = $market;
    $$mining{miner} = $$miner{name};
    $$mining{algo} = $$algo{name};
    $$mining{started} = time();
    $#{$$mining{speeds}} = -1;
  }

  # read from the perf pipe until the period elapses
  perf_startfile($miner, $algo);

  my $T = time();
  my $buffer = '';
  my $data;

  my $rin = '';
  vec($rin, $miner_reader_fd, 1) = 1;
  vec($rin, $perf_reader_fd, 1) = 1;
  while(1)
  {
    my $r = select(my $rout = $rin, undef, undef, 5);

    if(!$miner_pid || !$perf_pid)
    {
      print("miner or perf terminated early!\n");
      last;
    }

    if($r <= 0)
    {
      # this happens if the perf process never emits a perf record
      last if (time() - $T) > ($opts{"switching-period"} * 1.2);
    }

    next unless $r > 0;

    # read from miner, write to perf, tee to stdout
    if(vec($rout, $miner_reader_fd, 1) == 1)
    {
      $r = POSIX::read($miner_reader_fd, $data, 0xffff);
      if(not defined $r)
      {
        die("read($miner_reader_fd) : $!") unless $!{EINTR};
      }
      if($r)
      {
        awrite(1, $data, $r);
        awrite($autominer_writer_fd, $data, $r);
      }
    }

    # read from perf, write to /bench/foo
    if(vec($rout, $perf_reader_fd, 1) == 1)
    {
      $r = POSIX::read($perf_reader_fd, $data, 0xffff);
      if(not defined $r)
      {
        die("read($perf_reader_fd) : $!") unless $!{EINTR};
      }
      if($r)
      {
        $buffer .= $data;

        # consume full lines
        while((my $nl = index($buffer, "\n")) >= 0)
        {
          my $line = substr($buffer, 0, $nl + 1, '');
          chomp $line;

          $line = "$line\n";
          syswrite($bench_fh, $line, length($line));
          perf_readline($miner, $algo, $line);
        }

        # minimize lost shares by switching right after reading a perf record
        last if (time() - $T) >= ($opts{"switching-period"});
      }
    }
  }

  # get performance from nicehash
  while(1)
  {
    $present = nicehash::current_performance($opts{"payout-address"}, $$mining{algo}, $$mining{market}, $$mining{started});
    last if $present;

    # throttled
    sleep 3;
  }

  # update mining speed samples for the current option
  push @{$$mining{speeds}}, $$present{speed};
  $#{$$mining{speeds}} = $opts{"actual-speed-samples"} - 1 if $#{$$mining{speeds}} >= $opts{"actual-speed-samples"};

  $$mining{speed} = 0;
  for my $speed (@{$$mining{speeds}})
  {
    $$mining{speed} += $speed;
  }
  $$mining{speed} /= ($#{$$mining{speeds}}) + 1;

  # load market stats
  $rates{"nicehash-usa"} = getrates("nicehash-usa", $opts{"trailing-window"}) if $opts{"nicehash-usa"};
  $opportunities{"nicehash-usa"} = getopportunities("nicehash-usa") if $opts{"nicehash-usa"};

  $rates{"nicehash-eu"} = getrates("nicehash-eu", $opts{"trailing-window"}) if $opts{"nicehash-eu"};
  $opportunities{"nicehash-eu"} = getopportunities("nicehash-eu") if $opts{"nicehash-eu"};

  # the header line contains details about the selected option
  $perf_summary = perf_summary($mining, $option, \%rates, \%opportunities, $present);
  syswrite($bench_fh, $perf_summary, length($perf_summary));

  # the header line contains details about the selected option
  my $perf_footer = sprintf("%14.8f * %14.8f = %14.8f\n"
    , $$present{price}
    , $$present{speed}
    , $$present{price} * $$present{speed}
  );
  syswrite($bench_fh, $perf_footer, length($perf_footer));

  close($bench_fh);
  perf_endfile($miner, $algo, $benchdir, $bench_file_num);
  perf_update($miner, $algo, $benchdir);
}

killfast([ \$miner_pid, \$perf_pid, \$nicehash_aggregator_eu_pid, \$nicehash_aggregator_usa_pid ]);
